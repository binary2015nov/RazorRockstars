@{
    Layout = "_Layout";
    ViewBag.Title = "Razor Rockstars";
}
<style type="text/css">
    body {
        font-size: 120%;
        line-height: 120%;
        background: #e6e6e6 url(/img/rip_jobs.png);
        background-attachment: fixed;
    }
    #preview {
        font-size: 13px;
        line-height: 18px;
    }
    #page {
        border-top: 2px solid #BDBEC0;
        background: #fff url(/img/title-bg.png) no-repeat 0 5px;
    }
    #ss-link {
        position: absolute;
        display: block;
        width: 450px;
        height: 100px;
        margin: 0 0 0 -30px;
    }
    a {
        color: #093;
    }
    h1 {
        color: seagreen;
    }
    h3 {
        color: skyblue;
        color: #666;
    }
    #visual-sitemap {
        float: right;
        width: 220px;
        margin: 0 -90px 0 0;
        padding: 0 0 0 48px;
    }
    #visual-sitemap a {
        display: block;
        margin: 20px 0 0 0;
        line-height: 0;
        box-shadow: 0 3px 8px rgba(100, 100, 100, 0.3);
    }
    #visual-sitemap a.dead:hover {
        background: rgba(255,170,170,.5);
        background: rgba(255,255,204,.5);
    }
    #visual-sitemap a.alive:hover {
        background: rgba(170,255,170,.5);
    }
    #visual-sitemap img {
        padding: 5px;
        width: 150px;
    }
    #features li {
        line-height: 22px;
    }
    .preview {
        padding: 5px;
        box-shadow: 0 3px 8px rgba(100, 100, 100, 0.3);
    }
    ul {
        list-style-type: none;
    }
    #features li {
        font-weight: bold;    
    }
    #features li ul li {
        font-weight: normal;
    }
    #routes {
        margin: 0 0 0 15px;
    }
    #routes dt {
        width: 150px;
    }
    pre {
        background-color: #F8F8F8;
        border: 1px solid #CCC;
        font-size: 13px;
        line-height: 19px;
        overflow: auto;
        border-radius: 3px;
    }
    ul.urls li {
        font-weight: normal;
    }
    ul.urls li a {
        width: 400px;
        display: inline-block;        
    }
    .nuget-badge code {
        background-color: #202020;
        border: 4px solid #c0c0c0;
        border-radius: 5px;
        -moz-border-radius: 5px;
        -webkit-border-radius: 5px;
        box-shadow: 2px 2px 3px #6e6e6e;
        color: #e2e2e2;
        display:block;
        font: 1.5em 'andale mono', 'lucida console', monospace; 
        line-height: 1.5em;
        overflow: auto;
        padding: 15px; 
    }
    .line-data { width: 100%; }
</style>
<div id="page">
  	<a href="http://github.com/NetCoreApps/RazorRockstars/">
		<img style="position:absolute;top:0;right:0;border:0;z-index:1031" 
			 src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" 
             alt="Fork me on GitHub">
	</a>  
      
     <div id="visual-sitemap">
         <a class="dead" href="/stars/dead/cobain/"><img src="/img/thumb-05.jpg" /></a>
         <a class="alive" href="/stars/alive/Grohl"><img src="/img/thumb-01.jpg" /></a>
         <a class="dead" href="/stars/dead/hendrix/"><img src="/img/thumb-06.jpg" /></a>
         <a class="alive" href="/stars/alive/vedder/"><img src="/img/thumb-02.jpg" /></a>
         <a class="dead" href="/stars/dead/jackson/"><img src="/img/thumb-07.jpg" /></a>
         <a class="alive" href="/stars/alive/springsteen/"><img src="/img/thumb-03.jpg" /></a>
         <a class="dead" href="/stars/dead/presley/"><img src="/img/thumb-09.jpg" /></a>
         <a class="alive" href="/stars/alive/love/"><img src="/img/thumb-04.jpg" /></a>
         <a class="dead" href="/stars/dead/joplin/"><img src="/img/thumb-08.jpg" /></a>
     </div>

    <a id="ss-link" href="http://github.com/NetCoreApps/LiveDemos"></a>

    <h2 style="padding-top: 220px">ServiceStack's new HTML powers - the website framework</h2>
    <p>
        Razor Rockstars is a <a href="https://servicestack.net">ServiceStack</a> demo website 
        showcasing ServiceStack's new MVC Razor Engine support and its enriched HTML story 
        with multiple view engine support and No Controller / No Ceremony development options.
        In many cases we've gone beyond what MVC provides with many new and natural features 
        optimized for developer happiness, fast iteration times and run-time performance, 
        putting the fun back into .NET / Mono web development!
    </p>
    
    <a name="install"></a>
    <h2>Install via NuGet</h2>  
    <p>
        ServiceStack's Razor ViewEngine is an <b>optional .NET 4.5 add-on</b> that's self-contained 
        within the
        <a href="http://docs.servicestack.net/plugins.html">RazorFormat plugin</a>
        which can be easily added to any <b>empty ASP.NET or Console Application</b> project via NuGet with:
    </p>
    
    <div class="nuget-badge">
        <p>
            <code>PM&gt; Install-Package ServiceStack.Mvc</code>
        </p>
    </div>    

    <p>    
        Once added to your project, opt-in to enable the Razor feature in your AppHost with:
    </p>
    
    <pre><code>
    Plugins.Add(new RazorFormat());
    </code></pre>
     
    <img class="preview" src="/img/markup-impl.png" width="200" height="179" align="right" alt="Source code embedded in all pages" />
    <h3>All pages includes the code and markup used to render itself</h3>
    <p>
        To make it easier to explore all features on this site and to provide a better idea of how 
        it all fits together, all pages include gists of the source code used to render itself. 
        Source code for this entire website is in the 
        <a href="https://github.com/NetCoreApps/RazorRockstars">RazorRockstars Github project</a>.
    </p>
    
    <a name="features"></a>
    <h2>Website framework features</h2>
    <p>
        We've added features beyond MVC in true ServiceStack-style: by enhancing your existing 
        services, working as you'd expect it to in a REST service framework:
    </p>
    
    <ul id="features">
        <li>
            <a href="#runs-everywhere">Runs Everywhere</a>
            <ul>
                <li>In ASP.NET or Self-host, first-class cross-platform support on .NET / Mono runtimes</li>
            </ul>
        </li>
        <li>
            <a href="#easy">Nothing to learn</a>
            <ul>
                <li>Invisible API - just you and your IOC</li>
                <li>All services, filters, validators are auto-wired</li>
                <li>Services are implemented with ideal, untainted C#</li>
            </ul>
        </li>
        <li>
            <a href="#complete-stack">A Complete Web + REST Services Stack</a>            
            <ul>
                <li>Complete replacement for ASP.NET MVC and Web API</li>
                <li>Same service re-useable within HTML/JSON/XML/CSV/JSV/SOAP REST, RPC and MQ services</li>
                <li>HTML format supports multiple pluggable view engines</li>
                <li>Include Partials from other view engines</li>
            </ul>
        </li>
        <li>
            <a href="#unified-stack">One simple and unified HTTP stack</a>            
            <ul>
                <li>HTML format is just another Content-Type</li>
                <li>Add HTML views to existing services</li>
                <li>Change Views and Layout templates at runtime</li>
            </ul>
        </li>
        <li>
            <a href="#no-ceremony">The No Ceremony option</a>            
            <ul>
                <li>Dynamic pages without controllers</li>
                <li>Pretty urls by default (no custom Routes needed)</li>
                <li>Default pages for directories</li>
                <li>Keep all views and their assets together</li>
            </ul>
        </li>
        <li>
            <a href="#smart-views">Smart View Pages</a>
            <ul>
                <li>Pages with typed View Models</li>
                <li>Pages with dynamic View Models</li>
                <li>Access IOC dependencies directly in Views</li>
                <li>Easily configure custom error pages in code</li>
            </ul>
        </li>
        <li>
            <a href="#optimized-for-dev">Optimized for developer productivity</a>            
            <ul>
                <li>Great performance, Optimized for run-time and iteration times</li>        
                <li>Automatic reload of modified views, layout templates and partials (in Debug mode)</li>
            </ul>
        </li>
        <li>
            <a href="#future">Future developer productivity enhancements</a>            
            <ul>
                <li>Optimizing for Single Page Apps</li>
                <li>Hybrid Dynamic Web + Typed Services Stack - Best of both worlds</li>
            </ul>
        </li>
    </ul>
    
    <a name="runs-everywhere"></a>
    <h2>Runs Everywhere</h2>
    <p>
        Like the rest of ServiceStack, you can create websites and REST services in any host on any platform, e.g:
    </p>
    <ul>
        <li>
            <a href="https://github.com/NetCoreApps/RazorRockstars/tree/master/src/RazorRockstars.WebHost">
                ASP.NET Core Host
            </a>
        </li>
        <li>
            <a href="https://github.com/ServiceStackApps/RazorRockstars/">
                .NET 4.5 Framework
            </a>
            <ul>
                <li><a href="https://github.com/ServiceStackApps/RazorRockstars/tree/master/src/RazorRockstars.WebHost">Any ASP.NET host</a></li>
                <li><a href="https://github.com/ServiceStackApps/RazorRockstars/tree/master/src/RazorRockstars.SelfHost">A Stand-alone, self-hosted HttpListener</a></li>
                <li><a href="https://github.com/ServiceStackApps/RazorRockstars/tree/master/src/RazorRockstars.WinService">A Stand-alone Windows Service</a></li>
                <li>
                    Self-hosted HttpListener with

                    <ul>
                        <li><a href="https://github.com/ServiceStack/ServiceStack.Gap#self-hosting-console-app">Entire App ILMerged into a single cross-platform App.exe</a></li>
                        <li><a href="https://github.com/ServiceStack/ServiceStack.Gap#winforms-with-chromium-embedded-framework">Hosted inside WinForms with Chromium Embedded Framework</a></li>
                        <li><a href="https://github.com/ServiceStack/ServiceStack.Gap#mac-osx-cocoa-app-with-xmarainmac">Hosted inside Mac OSX Cocoa App with Xmarain.Mac</a></li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
   
    <a name="easy"></a>
    <h2>Nothing to learn</h2>
    <h3>Invisible API - just you and your IOC</h3>
    <p>
        One of ServiceStack's core objectives is to retain an invisible API that gets out of your way.
        The ServiceStack service itself is a classic example, it's just a 
        <a href="https://github.com/NetCoreApps/RazorRockstars/blob/f71a3b30f353f1fed1126f36c86d4d59f2235327/src/RazorRockstars.WebHost/RockstarsService.cs#L37">simple C# class</a> auto-wired with your registered dependencies that accepts any user-defined Request DTO and 
        lets you return any object which is automatically serialized into the expected Response Content-Type. 
        Composable and re-usable functionality can be applied to all your services via 
        <a href="http://docs.servicestack.net/request-and-response-filters.html">Request / Response Filters</a>, 
        <a href="http://docs.servicestack.net/filter-attributes.html">Filter Attributes</a>, 
        <a href="http://docs.servicestack.net/validation.html#validation-feature">Validators</a> or by extending a common base class -
        all of which get auto-wired with your registered dependencies. Even Razor views have access to your IOC dependencies.
    </p>
    <p>
        You retain complete control over the Request DTO, Implementation and Response - added features simply enhance your existing 
        models and services. We refer to this style as <b>starting from ideal C#, and project-out</b> and is one of the key approaches 
        we use to promote a frictionless dev workflow, i.e. instead of having your C# code bind to a foreign API abstraction, ServiceStack builds functionality around your untainted C# classes and DTOs (unhindered by artificial APIs). 
        This makes your logic more re-usable and is how any new feature we add to the framework is immediately able to work with your 
        existing services without any code-changes required.
        E.g. you can code as you would normally and throw C# Exceptions and the ideal HTTP Response gets emitted, you also have access to 
        <a href="http://docs.servicestack.net/validation.html#validation-feature">rich fluent validation</a>         
        that supports returning typed structured error responses back to C# clients.
    </p>
    
    <h3>Include Partials from other view engines</h3>
    <p>
        Unlike many web frameworks, ServiceStack lets you include Partial views from other registered view engines.
        This is ideal for Content heavy pages where you can use MVC Razor format for a precise layout whilst maintaining
        the content of your dynamic pages in Markdown. 
    </p>
    <p>
        All <a href="/stars/dead/cobain">Dead</a> and <a href="/stars/alive/Grohl">Alive</a> individual Rockstar pages are maintained in this way.
    </p>

    <a name="complete-stack"></a>
    <h2>A Complete Web + REST Services Stack</h2>
    <p>
        The new Razor and multiple HTML ViewEngine support now transforms ServiceStack from a Web Services framework to a complete 
        Website + REST/SOAP/MQ services stack which provides a clean replacement for MVC, WCF or WebApi.
    </p>
    <p>
        This is a clean-break from the layers of legacy frameworks that have been added to ASP.NET over the years. 
        We've made everything simpler by removing all existing ASP.NET layers and xml-encumered providers added 
        on top of IHttpHandler's since .NET 2.0 and replaced them with clean, testable code-first providers based 
        on urls and clean POCOs - all working seamlessly together.
    </p>

    <h3>HTML format supports multiple pluggable view engines</h3>
    <p>
        HTML support works just as you would expect it to exist on a REST service framework - 
        you get to re-use your existing web service implementation where HTML is just another Content-Type: 
    </p>
    <p style="text-align:center;padding:10px;">
        <a href="http://docs.servicestack.net/architecture-overview.html">
            <img class="preview" src="/img/architecture-htmlformat.png" alt="ServiceStack Architecture" /></a>
    </p>
    <p>
        ServiceStack supports multiple view engines out-of-the-box: By default 
        <a href="http://docs.servicestack.net/html5reportformat.html">HtmlReport</a> and 
        <a href="http://docs.servicestack.net/markdown-razor.html">Markdown</a> 
        is pre-registered, whilst Razor support can be <a href="#install">installed via NuGet</a>.
    </p>

    <p>
        When the client requests HTML Content-Type, ServiceStack will cycle through all registered view engines 
        to find a matching view, if no matches are found the 
        <a href="http://docs.servicestack.net/html5reportformat.html">HtmlReport</a>
        is used as a fallback which provides a readable and semantic HTML layout letting you visualize all the 
        data returned from your web service at a glance.
    </p>
    
    <a name="unified-stack"></a>
    <h2>One simple and unified HTTP stack</h2>
    <p>
        ServiceStack has a single, simple unified HTTP stack. There is no duplicate or supplementary 
        functionality that only works for HTML vs Services. Everything is kept simple: 
        There is 1 set of Routes, 1 way to create a Service, 1 set of Request / Response filters, 1 Validation model.
        All of ServiceStack's plugins and providers work equally well across all services 
        and can even be shared from within MVC / WebForms hybrid solutions.
    </p>
    <h3>Add HTML views to existing services</h3>
    <p>
        The benefits of this are prominent, you only have a single implementation for all your Mobile, 
        Desktop or Web Browser clients. By default, your clean C#-only services is accessible via 
        HTML, JSON, XML, CSV, JSON, SOAP, ProtoBuf and MQ endpoints - all with no effort.
    </p>
    <img class="preview" src="/img/rockstars-view.png" align="right" style="margin-left: 20px;" alt="Solution view of Rockstars page" />
    <p>
        A live example of this is the 
        <a href="https://github.com/NetCoreApps/RazorRockstars/blob/master/src/RazorRockstars.WebHost/RockstarsService.cs">RockstarsService.cs</a>
        which is available by any of the defined custom routes, e.g:
    </p>
    <dl id="routes">
        <dt><a href="/rockstars">/rockstars</a></dt>
        <dd>
            <a href="/rockstars.json">json</a>
            <a href="/rockstars.xml">xml</a>
            <a href="/rockstars.csv">csv</a>
            <a href="/rockstars.jsv">jsv</a>
        </dd>
        <dt><a href="/rockstars/1">/rockstars/1</a></dt>
        <dd>
            <a href="/rockstars/1.json">json</a>
            <a href="/rockstars/1.xml">xml</a>
            <a href="/rockstars/1.csv">csv</a>
            <a href="/rockstars/1.jsv">jsv</a>
        </dd>
        <dt><a href="/rockstars/aged/27">/rockstars/aged/27</a></dt>
        <dd>
            <a href="/rockstars/aged/27.json">json</a>
            <a href="/rockstars/aged/27.xml">xml</a>
            <a href="/rockstars/aged/27.csv">csv</a>
            <a href="/rockstars/aged/27.jsv">jsv</a>
        </dd>
    </dl>
    <p>
        When viewed in a browser it will return the HTML output generated by the 
        <a href="https://github.com/NetCoreApps/RazorRockstars/blob/master/src/RazorRockstars.WebHost/Views/Rockstars.cshtml"><b>Rockstars.cshtml</b></a> view 
        embedded inside the specified 
        <a href="https://github.com/NetCoreApps/RazorRockstars/blob/master/src/RazorRockstars.WebHost/Views/Shared/HtmlReport.cshtml"><b>HtmlReport.cshtml</b></a> template
        using the model populated by the 
        <a href="https://github.com/NetCoreApps/RazorRockstars/blob/master/src/RazorRockstars.WebHost/RockstarsService.cs"><b>RockstarsService.cs</b></a>
    </p>

    <p>
        Unlike MVC (which has a convention for views based on the name of the controller), ServiceStack's view selection 
        is based on the name of the Response or Request model (DTO) returned. E.g. If your Service returns a 
        <b>RockstarsResponse</b> then we first look for a view of the same name as the Request DTO called 
        <b>Rockstars.cshtml</b> followed by the Response DTO name <b>RockstarsResponse.cshtml</b> 
        (in all registered view engine extensions).
    </p>
    <p>
        As ServiceStack requires Request DTO's to be unique, you are free to layout the views in 
        any logical file system structure you wish under the <b>/Views</b> folder and are not forced into any
        existing MVC /Views/ControllerName/ViewName convention.
    </p>
    
    <h3>Change Views and Layout templates at runtime</h3>
    <p>
        The above convention is overrideable where you can change both what View and Layout Template is used at runtime by
        returning your Response inside a decorated <b>HttpResult</b>:
    </p>
    
    <pre><code>
    return new HttpResult(dto) {
        View = {viewName},
        Template = {layoutName},
    };
    </code></pre>
    
    <p>
        This is useful whenever you want to display the same page in specialized Mobile and Print Preview website templates.
        You can also let the client change what View and Template gets used by 
        <a href="https://github.com/NetCoreApps/RazorRockstars/blob/7ac4330ad3839d46e2b0e45d178f56a33d6cdf7d/src/RazorRockstars.WebHost/RockstarsService.cs#L59">attrubuting your service</a> 
        with the 
        <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ClientCanSwapTemplatesAttribute.cs">[ClientCanSwapTemplates]</a> 
        Filter:
    </p>

    <pre><code>
    [ClientCanSwapTemplates]
    public class RockstarsService : Service { ... }
    </code></pre>
    
    <p>
        This attribute allows the client to change what View gets used with the <b>View</b> and <b>Template</b> 
        QueryString or FormData Request Params. A live example of this feature is used to change the 
        <a href="/rockstars">/rockstars</a> page:        
    </p>
    
    <ul class="urls">
        <li><a href="/rockstars?View=AngularJS">/rockstars?View=AngularJS</a> Use an AngularJS View with client-side templating</li>
        <li><a href="/rockstars?Template=SimpleLayout">/rockstars?Template=SimpleLayout</a> Change Layout Template used</li>
        <li><a href="/rockstars?View=AngularJS&amp;Template=SimpleLayout">/rockstars?View=AngularJS&amp;Template=SimpleLayout</a> Change View and Template used</li>
    </ul>

    <a name="no-ceremony"></a>
    <h2>The No Ceremony option - Dynamic pages without Controllers</h2>
    <p>
        Many times (especially for read-only pages) Controllers add un-necessary overhead and just calling your 
        dynamic Razor (or Markdown) pages directly will promote more cohesive pages requiring less code. Especially
        if you're already encapsulating your data access logic behind domain services and repositories - the overhead
        of a controller and action methods just adds un-necessary noise, that ends up being harder to test than pure C# code.
    </p>
    
    <h3>Pretty urls by default (no custom Routes needed)</h3>
    <p>
        ServiceStack has great support for this story where it lets you omit the 
        <b class="rzr">.cshtml</b> or <b class="md">.md</b>
        page extensions and it still executes the desired page but with a pretty url.
        When calling dynamic pages with .ext (as done by VS.NET when hitting F5 inside a page)
        it is automatically re-directed to the pretty url version (saving a YSOD you might be used to with MVC):
    </p>
    
    <ul class="urls">
        <li><a href="/stars/alive/Grohl.cshtml">/stars/alive/Grohl.cshtml</a> -> /stars/alive/Grohl</li>
    </ul>
    
    <h3>Default pages for directories</h3>
    
    <ul class="urls">
        <li><a href="/stars/alive/vedder/default.cshtml">/stars/alive/vedder/default.cshtml</a> -> /stars/alive/vedder/</li>
    </ul>
    <p>
        The Above url shows the behaviour when requesting the default document <b>default.cshtml</b> 
        which gets redirected to the alias url of its parent directory.
    </p>

    <img class="preview" src="/img/grohl-vs-vedder.png" align="right" style="margin-left:20px;" alt="Single vs Multiple directories" />
    <p>
        The Dave Grohl and Eddie Vedder content pages show different ways of structuing the same page components whilst retaining the same url. 
        The Dave Grohl example shows how you can keep all Rockstar pages in a single directory with different names for each
        Grohl.cshtml razor page and GrohlContent.md partial markdown view.
    </p>

    <p>
        Eddie Vedder (and all the other Rockstars) use multiple sub directories to maintain their dynamic content pages
        and the different components that make up each page. Regardless of which layout you go with, you can still access
        the each page with the same case-insensitive pretty url:
    </p>

    <ul class="urls">
        <li><a href="/stars/alive/Grohl">/stars/alive/Grohl</a></li>
        <li><a href="/stars/alive/vedder/">/stars/alive/vedder/</a></li>
    </ul>
    
    <h3>Keep all views and their assets together</h3>
    <p>
        Despite both options yielding the same result, whenever you have many similar content pages it becomes a good idea 
        to adopt the 'multiple sub-directory' convention which apart from giving each page more symmetry, it will allow
        you to group all the websites dynamic and static content, images and css within the same folder that makes 
        copying, updating and deploying as easy as dragging and dropping a folder.  
    </p>
    
    <h3>Layout templates</h3>
    <p>
        Specifying Layouts for Razor Views and Pages follow MVC's convention where it looks for the Layout in your
        <b>/Views/Shared</b> folder. In this case the Razor Page of each Rockstar references either
        <b>/Views/Shared/AliveLayout.cshtml</b> or <b>/Views/Shared/AliveLayout.cshtml</b> to give each Rockstar 
        a different look:
    </p>
    
    <div style="float:left; margin: 0 50px 0 0;">
        <h4>Rockstars that have passed</h4>
        <ul>
            <li><a href="/stars/dead/cobain/">/stars/dead/cobain/</a></li>
            <li><a href="/stars/dead/hendrix/">/stars/dead/hendrix/</a></li>
            <li><a href="/stars/dead/jackson/">/stars/dead/jackson/</a></li>
            <li><a href="/stars/dead/joplin/">/stars/dead/joplin/</a></li>
            <li><a href="/stars/dead/presley/">/stars/dead/presley/</a></li>
        </ul>
    </div>

    <div style="float:left;">
        <h4>Rockstars still Rocking it</h4>
        <ul>
            <li><a href="/stars/alive/Grohl">/stars/alive/Grohl</a></li>
            <li><a href="/stars/alive/vedder/">/stars/alive/vedder/</a></li>
            <li><a href="/stars/alive/springsteen/">/stars/alive/springsteen/</a></li>
            <li><a href="/stars/alive/love/">/stars/alive/love/</a></li>
        </ul>
    </div>
    
    <b class="clear"></b>
    
    <a name="smart-views"></a>
    <h2>Smart View Pages</h2>
        
    <p>
        One features Controllers have is the ability to inspect the incoming request. 
        Inside Services, ServiceStack takes care of Request Binding and automatically populates your Request DTO based upon the HTTP Request Params.
        When calling pages directly (i.e. without Controllers) there are still a few ways to access the incoming HTTP Request data:
    </p>

    <h3>Pages with typed View Models</h3>    
    <p>
        In the same way ServiceStack populates the Request DTO in Services, it will auto populate your View model by in Views when
        inheriting from the Generic <b>ViewPage&lt;TModel&gt;</b> base class that's specified in the
        <a href="https://github.com/NetCoreApps/RazorRockstars/blob/master/src/RazorRockstars.WebHost/wwwroot/_ViewImports.cshtml">_ViewImports.cshtml</a>
        as seen in 
        <a href="/TypedModelNoController">/TypedModelNoController</a>:
    </p>

    <pre><code>
    @@model SearchRockstars
    </code></pre>
    
    <p>This will result in the typed <b>@@Model</b> being populated from the HTTP Request params</p>

    <h3>Pages with dynamic View Models</h3>
    <p>
        The above solution requires an existing typed Request DTO / Input Model.
        There's also the option of not requiring a View Model when inheriting from the non-Generic <b>ViewPage</b> as seen in 
        <a href="/NoModelNoController">/NoModelNoController</a>:
    </p>

    <pre><code>
    @@inherits ViewPage
    </code></pre>
    
    <p>
        In this case <b>@@Model</b> is a ViewDataDictionary that's populated from the Request's QueryString, FormData, Cookies and Items.
    </p>
    
    <h4>Access Request / Response properties in Views</h4>
    <p>
        In addition to the @@Model property, each View also has access to <b>base.Request</b> / <b>base.Response</b> 
        properties for more fine-grained access to ServiceStack's 
        <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Web/IHttpRequest.cs">IHttpRequest</a> and 
        <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Web/IHttpResponse.cs">IHttpResponse</a> 
        types.
    </p>
    
    <h3>Access IOC dependencies directly in Views</h3>
    
    <p>
        For dynamic views to also fullfill the roles of Controllers they need to be smart, which is why we've enabled 
        views the ability to resolve your registered IOC dependencies with:
    </p>

    <pre><code>
    var provider = TryResolve&lt;IYourProvider&gt;();
    </code></pre>
    
    <p>
        In addition to accessing IOC debendencies, base classes also provide quick access to the most common providers like 
        ADO.NET's <b class="db">IDbConnection</b> as well as ServiceStack's clean 
        <a href="http://docs.servicestack.net/sessions.html">Session</a> and
        <a href="http://docs.servicestack.net/caching.html">Caching</a> providers.
    </p>
    
    <p>
        Many Micro ORMs like 
        (<a href="https://github.com/ServiceStack/ServiceStack.OrmLite/">OrmLite</a> and 
        <a href="http://code.google.com/p/dapper-dot-net">Dapper</a>)
        provide extension methods on ADO.NET's IDbConnection making it trivial to perform common db tasks. 
        Here's an example of filtering the results of the Rockstar table with a typed Request Param:
    </p>
    
    <pre><code>
    var rockstars = Db.Select&lt;Rockstar&gt;(q => q.Age == Model.Age);
    </code></pre>

    <h3>Easily configure custom error pages in code</h3>
    <p>
        Since all common web tasks should be easy to configure, we've made it easy to register your own custom IHttpHandler's
        for different HTTP Status codes which you can do in your AppHost with:
    </p>

    <pre><code>
    this.CustomErrorHttpHandlers[HttpStatusCode.Unauthorized] = new RazorHandler("/login");
    </code></pre>

    <p>
        For NotFound requests we recommend instead to use .NET Core's convention of just registering a 
        <b>Catch-All</b> Middleware at the end of the App Builder Pipeline. ServiceStack HttpHandlers can
        be registered as a .NET Core module as-is so we're able to re-use our existing <b>RazorHandler</b>
        here as well, e.g:
    </p>

    <pre><code>
    app.Use(new RazorHandler("/notfound"));
    </code></pre>

    <p>
        Which you can test by looking for a Rockstar that doesn't exist on this site, e.g:
    </p>
    
    <ul class="urls">
        <li><a href="/stars/alive/coldplay">/stars/alive/coldplay</a></li>
    </ul>
    
    <p>
        This rule tells ServiceStack to execute the <b>/notfound</b> Razor page for all 404 requests. 
        The page referenced by Razor handler can be any dynamic razor page (i.e. not just a static html page) - 
        which is extremely useful for Single Page Apps taking advantage of the DOM's history.pushState().
    </p>
    
    <a name="markdown"></a>
    <h2>Markdown built-in</h2>
    <p>
        Another templating language we're especially fond of is <a href="http://daringfireball.net/projects/markdown/">Markdown</a>. 
        Although as the name suggests it's more of a <b>Mark Down language</b> since it's able to express commonly used HTML elements 
        used for structuring content down into a simple syntax you may conventionally see published in ascii-only environments 
        like plain-text email. 
    </p>

    <h3>Maintain Content in Markdown (ideal for Content)</h3>
    <p>
        Markdown's overriding design goal is to be as human readable as possible where markdown text published on its own is still 
        readable as-is and can be easily written in any text editor, without the need for any Visual HTML designer. 
        These properties make Markdown the choice language to capture and maintain user content as done in many popular sites 
        including <a href="http://stackoverflow.com">StackOverflow</a> and <a href="https://github.com">GitHub</a>.
    </p>

    <h3>Include Partial Markdown views in Razor pages</h3>
    <p>
        As we expect Razor + Markdown to be an increasingly popular combination we've extend <b>@@Html.PartialMarkdown()</b> support to
        also embed Partials from Markdown pages inside Razor Views. This feature lets you embed any Markdown Page as we've done in 
        each of the <a href="/stars/alive/vedder/">content-heavy</a> <a href="/stars/dead/cobain/">Rockstar pages</a> using the 
        Razor syntax below:
    </p>

    <pre><code>
    @@Html.PartialMarkdown("Content")
    </code></pre>
    
    <p>
        Which tells ServiceStack to embed a Partial named <b>Content.md</b> inside the page at that location. 
        Initially it searches the current directory, followed by any matching Partials in the <b>/Views/Shared</b> folder.
        If you wanted to render a Markdown string instead you can use <b>@@Html.RenderMarkdown()</b>, e.g:
    </p>

    <pre><code>
    @@Html.RenderMarkdown("## Heading")
    </code></pre>

    <a name="optimized-for-dev"></a>
    <h2>Optimized for developer productivity</h2>
    <p>
        One of the areas where dynamic languages are holding over .NET is with fast iteration times enabling quick dev cycles. 
        Whilst compilation times increase with every new page and class added to an ASP .NET Web project, 
        many popular dynamic languages are experimenting with <b>Live Reloading</b> letting them quickly see changes in their browser 
        after hitting <b>Ctrl+S</b>.
        Iteration times are one of the areas in most need of TLC in .NET and it's something we aim to optimize as much as possible 
        without sacrificing run-time performance by maintaining 2 modes: 'Debug' (Development) optimized for start times and a 'Release' 
        (Deployment) mode optimized for runtime performance. This mode is automatically inferred by ServiceStack on Start-up but is overridable with: 
    </p>

    <pre><code>
    SetConfig(new HostConfig {
        DebugMode = true,
    });
    </code></pre>
    
    <a name="future"></a>
    <h2>Future developer productivity enhancements</h2>

    <h3>Optimizing for Single Page Apps</h3>
    <a href="https://github.com/ServiceStack/ServiceStackVS/blob/master/angular-spa.md"><img src="/img/AngularJS-large.png" align="right" style="padding:10px 20px 20px 20px; width:268px;" /></a>
    <p>
        One way we're currently improving the situation (that also provides a better UX for end-users) has been focusing on making 
        ServiceStack the ideal platform for Single Page Apps
        - to this end, we're already shipping many <a href="https://github.com/ServiceStack/ServiceStackVS">best-of-class features</a> 
        and since Single Page Apps rely on client-side views for rendering, they escape the .NET compilation tax. 
    <p>
    </p>
        With the latest release of WebStorm, JetBrains gives us a glimpse into the 
        <a href="http://www.youtube.com/watch?v=wCVwdvufTds&feature=youtu.be">development experience of Live Editing</a> 
        where they showcase the instant feedback loop possible when developing a rich client-side AngularJS App With WebStorm and Chrome.
    </p>
    <a href="https://github.com/ServiceStackApps/Chat-React#modern-reactjs-apps-with-net"><img src="/img/react-logo.png" align="left" style="padding:10px 20px 20px 0px; width:268px;" /></a>
    <p>
        With this release of MVC Razor support, ServiceStack is a complete and integrated Web and Web Service Framework where 
        we're able to simplify Web and Web Service development using just Services and Razor for generating HTML UIs. 
    </p>
    
    <h3>ServiceStackVS Single Page App Templates</h3>
    <p>
        Included in
        <a href="https://github.com/ServiceStack/ServiceStackVS">ServiceStackVS</a> are Single Page App templates for
        the most popular client-side frameworks:
        <a href="https://github.com/ServiceStackApps/Chat-React#modern-reactjs-apps-with-net">React</a> and
        <a href="https://github.com/ServiceStack/ServiceStackVS/blob/master/angular-spa.md">AngularJS</a>,
        our exciting
        <a href="https://github.com/ServiceStackApps/ReactDesktopApps">React Desktop Apps</a> template takes this one step further and
        provides all the tools to package your ASP.NET React Web App into an Winforms, OSX Cocoa and Linux/Win/OSX Console App
        We'll continue to improve this story and ensure first-class support for advanced Web App features with integration with SPA
        Routing frameworks, which has always awkward to be able to do in MVC.
    </p>
    <b class="clear"></b>
</div>
 
 
<div id="preview">
    <h1>Implementation</h1>
    
    <h3><b>AppHost</b> <a href="https://github.com/NetCoreApps/RazorRockstars/blob/master/src/RazorRockstars.WebHost/Startup.cs">/Startup.cs</a></h3>
    <p>
        In every ServiceStack web service there is a single AppHost which contains all your 
        services configuration and registration (in code). 
        The source for the Razor Rockstars AppHost is below, it performs the following things in this order:
    </p>
    <ol>
        <li>Tells ServiceStack which Assemblies to scan for registering existing services</li>
        <li>Register the MVC Razor Plugin (requires .NET 4.5)</li>
        <li>Register which DB to use - Razor Rockstars uses OrmLite + Sqlite (32bit/Mono compat)</li>
        <li>Create the <b class="src">Rockstar</b> table if it doesn't already exist and insert all Seed Data</li>
        <li>Override ServiceStack's 404 Handler with the <b class="src">/NotFound.cshtml</b> Razor page</li>
    </ol>
    <script src="https://gist.github.com/gistlyn/956a1c5cb7a13240daa7f1ea00ab8881.js"></script>
    

</div>
